From 1088ff0f84c04b1b73e3e9166a3532122230914e Mon Sep 17 00:00:00 2001
From: Vlad Zagorodniy <vladzzag@gmail.com>
Date: Wed, 15 Aug 2018 19:40:50 +0300
Subject: [PATCH] RFC: Keep Deleted transients above old parents

Summary:
If a modal window is closed, usually, it will go behind its parent. The
reason for this is that Workspace::constrainedStackingOrder() puts only
AbstractClient transients above parents, not Deleted transients.

So, if fade/glide/scale effect animates the disappearing of a transient,
unfortunately, one can't see that animation.

== Demos

=== Closing of a transient and parent window

Before:

https://www.youtube.com/watch?v=XiLq7EAVCp0

After:

https://www.youtube.com/watch?v=cH_Ki-sqY8M

=== Scale effect

Before:

https://www.youtube.com/watch?v=Eb2a3U7R10I

After:

https://www.youtube.com/watch?v=4AKu3fdrnYQ

=== Sheet effect

Before:

https://www.youtube.com/watch?v=xPPSnR5FUU0

After:

https://www.youtube.com/watch?v=o_hxTNT-5Hg

Reviewers: #kwin

Subscribers: kwin

Tags: #kwin

Differential Revision: https://phabricator.kde.org/D14868
---
 deleted.cpp | 34 +++++++++++++++++++
 deleted.h   | 14 ++++++++
 layers.cpp  | 95 ++++++++++++++++++++++++++++++++---------------------
 3 files changed, 106 insertions(+), 37 deletions(-)

diff --git a/deleted.cpp b/deleted.cpp
index 61b8dbd82..2d791b1d7 100644
--- a/deleted.cpp
+++ b/deleted.cpp
@@ -55,6 +55,12 @@ Deleted::~Deleted()
     if (workspace()) {
         workspace()->removeDeleted(this);
     }
+    if (auto *transientFor = qobject_cast<Deleted *>(m_transientFor)) {
+        transientFor->removeDeletedTransient(this);
+    }
+    for (Deleted *deleted : qAsConst(m_deletedTransients)) {
+        deleted->setWasTransientFor(nullptr);
+    }
     deleteEffectWindow();
 }
 
@@ -112,9 +118,37 @@ void Deleted::copyToDeleted(Toplevel* c)
         }
         m_fullscreen = client->isFullScreen();
         m_wasCurrentTab = client->isCurrentTab();
+
+        m_transientFor = client->transientFor();
+        if (m_transientFor != nullptr) {
+            connect(m_transientFor, &Toplevel::windowClosed, this,
+                [this](Toplevel *toplevel, Deleted *deleted) {
+                    Q_UNUSED(toplevel)
+                    m_transientFor = deleted;
+                    if (deleted != nullptr) {
+                        deleted->addDeletedTransient(this);
+                    }
+                }
+            );
+        }
     }
 }
 
+void Deleted::addDeletedTransient(Deleted *transient)
+{
+    m_deletedTransients.append(transient);
+}
+
+void Deleted::removeDeletedTransient(Deleted *transient)
+{
+    m_deletedTransients.removeAll(transient);
+}
+
+void Deleted::setWasTransientFor(Deleted *transientFor)
+{
+    m_transientFor = transientFor;
+}
+
 void Deleted::unrefWindow()
 {
     if (--delete_refcount > 0)
diff --git a/deleted.h b/deleted.h
index 0aa88e726..e0a50effa 100644
--- a/deleted.h
+++ b/deleted.h
@@ -74,6 +74,15 @@ public:
     QList<AbstractClient*> mainClients() const {
         return m_mainClients;
     }
+    bool wasTransient() const {
+        return m_transientFor != nullptr;
+    }
+    Toplevel *wasTransientFor() const {
+        return m_transientFor;
+    }
+    DeletedList deletedTransients() const {
+        return m_deletedTransients;
+    }
     NET::WindowType windowType(bool direct = false, int supported_types = 0) const;
     bool wasClient() const {
         return m_wasClient;
@@ -99,6 +108,9 @@ private Q_SLOTS:
 private:
     Deleted();   // use create()
     void copyToDeleted(Toplevel* c);
+    void addDeletedTransient(Deleted *transient);
+    void removeDeletedTransient(Deleted *transient);
+    void setWasTransientFor(Deleted *transientFor);
     virtual ~Deleted(); // deleted only using unrefWindow()
     int delete_refcount;
     double window_opacity;
@@ -125,6 +137,8 @@ private:
     NET::WindowType m_type = NET::Unknown;
     QByteArray m_windowRole;
     bool m_fullscreen;
+    Toplevel *m_transientFor = nullptr;
+    DeletedList m_deletedTransients;
 };
 
 inline void Deleted::refWindow()
diff --git a/layers.cpp b/layers.cpp
index caa7db1d3..367367177 100644
--- a/layers.cpp
+++ b/layers.cpp
@@ -528,57 +528,78 @@ ToplevelList Workspace::constrainedStackingOrder()
     for (int i = stacking.size() - 1;
             i >= 0;
        ) {
-        AbstractClient *current = qobject_cast<AbstractClient*>(stacking[i]);
-        if (!current || !current->isTransient()) {
-            --i;
-            continue;
-        }
         int i2 = -1;
-        Client *ccurrent = qobject_cast<Client*>(current);
-        if (ccurrent && ccurrent->groupTransient()) {
-            if (ccurrent->group()->members().count() > 0) {
-                // find topmost client this one is transient for
-                for (i2 = stacking.size() - 1;
-                        i2 >= 0;
-                        --i2) {
-                    if (stacking[ i2 ] == stacking[ i ]) {
-                        i2 = -1; // don't reorder, already the topmost in the group
-                        break;
+        bool hasTransients = false;
+
+        if (auto *current = qobject_cast<AbstractClient*>(stacking[i])) {
+            if (current->isTransient()) {
+                Client *ccurrent = qobject_cast<Client*>(current);
+                if (ccurrent && ccurrent->groupTransient()) {
+                    if (ccurrent->group()->members().count() > 0) {
+                        // find topmost client this one is transient for
+                        for (i2 = stacking.size() - 1;
+                                i2 >= 0;
+                                --i2) {
+                            if (stacking[ i2 ] == stacking[ i ]) {
+                                i2 = -1; // don't reorder, already the topmost in the group
+                                break;
+                            }
+                            AbstractClient *c2 = qobject_cast<AbstractClient*>(stacking[ i2 ]);
+                            if (!c2) {
+                                continue;
+                            }
+                            if (c2->hasTransient(current, true)
+                                    && keepTransientAbove(c2, current))
+                                break;
+                        }
+                    } // else i2 remains pointing at -1
+                } else {
+                    for (i2 = stacking.size() - 1;
+                            i2 >= 0;
+                            --i2) {
+                        AbstractClient *c2 = qobject_cast<AbstractClient*>(stacking[ i2 ]);
+                        if (!c2) {
+                            continue;
+                        }
+                        if (c2 == current) {
+                            i2 = -1; // don't reorder, already on top of its mainwindow
+                            break;
+                        }
+                        if (c2 == current->transientFor()
+                                && keepTransientAbove(c2, current))
+                            break;
                     }
-                    AbstractClient *c2 = qobject_cast<AbstractClient*>(stacking[ i2 ]);
-                    if (!c2) {
-                        continue;
+                }
+            }
+            hasTransients = !current->transients().isEmpty();
+        } else if (auto *deleted = qobject_cast<Deleted*>(stacking[i])) {
+            if (deleted->wasTransient()) {
+                for (i2 = stacking.size() - 1; i2 >= 0; --i2) {
+                    const Toplevel *toplevel = stacking[i2];
+
+                    if (toplevel == deleted) {
+                        i2 = -1;
+                        break;
                     }
-                    if (c2->hasTransient(current, true)
-                            && keepTransientAbove(c2, current))
+
+                    // TODO: Check whether we have to keep the transient above?
+                    if (toplevel == deleted->wasTransientFor()) {
                         break;
+                    }
                 }
-            } // else i2 remains pointing at -1
-        } else {
-            for (i2 = stacking.size() - 1;
-                    i2 >= 0;
-                    --i2) {
-                AbstractClient *c2 = qobject_cast<AbstractClient*>(stacking[ i2 ]);
-                if (!c2) {
-                    continue;
-                }
-                if (c2 == current) {
-                    i2 = -1; // don't reorder, already on top of its mainwindow
-                    break;
-                }
-                if (c2 == current->transientFor()
-                        && keepTransientAbove(c2, current))
-                    break;
+
+                hasTransients = !deleted->deletedTransients().isEmpty();
             }
         }
         if (i2 == -1) {
             --i;
             continue;
         }
+        Toplevel *current = stacking[i];
         stacking.removeAt(i);
         --i; // move onto the next item (for next for () iteration)
         --i2; // adjust index of the mainwindow after the remove above
-        if (!current->transients().isEmpty())   // this one now can be possibly above its transients,
+        if (hasTransients)   // this one now can be possibly above its transients,
             i = i2; // so go again higher in the stack order and possibly move those transients again
         ++i2; // insert after (on top of) the mainwindow, it's ok if it2 is now stacking.end()
         stacking.insert(i2, current);
-- 
2.18.0

