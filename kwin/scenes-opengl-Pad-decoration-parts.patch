From dc87d2c9581aa7f575b9cf783cd06e75f3b60e77 Mon Sep 17 00:00:00 2001
From: Vlad Zagorodniy <vladzzag@gmail.com>
Date: Sat, 16 Jun 2018 22:33:52 +0300
Subject: [PATCH] [scenes/opengl] Pad decoration parts

Summary:
Internally, OpenGL scene plugin stores each decoration in a texture
atlas to avoid unnecessary texture bind calls. This works great until
there is no need for the linear filter. If the texture atlas is scaled
and the linear filter is used, texture bleeding could happen.

<-- image -->

Texture bleeding happens because linear filter samples texels that are
outside of a subtexture.

There are several ways to fix the texture bleeding:
* the first one is so known "half pixel correction". With half pixel
  correction value of half a texel is added or subtracted so when linear
  filter comes in it samples texels in desired region;
* another way to fix the texture bleeding are array texture.
  Unfortunately, decoration pieces could have different size so array
  textures wouldn't help;
* and the last one is to pad each subtexture.

It's very easy to implement half pixel correction. But because mapped
subtexture is smaller by 1px, the linear filter would always kick in and
"blur" fonts.

So, the only choice we have is to pad each subtexture. This diff, as its
name suggests, makes decoration renderer to pad each decoration piece by
1px:

<-- image -->
//Decoration atlas for active Dolphin window.//

Yet, there are still some problems on X11. Because window pixmaps also
include window decorations, clamp to edge would not help. I.e. window
pixmaps bleed on X11.

<-- image -->
//X11: Zoom effect.//

<-- image -->
//Wayland: Zoom effect.//

CCBUG: 360549

Test Plan: Zoomed screen, decorations are no longer bleeding.

Reviewers: #kwin, davidedmundson, fredrik, graesslin

Subscribers: kwin, fvogt

Tags: #kwin

Differential Revision: https://phabricator.kde.org/D13575
---
 plugins/scenes/opengl/scene_opengl.cpp | 63 +++++++++++++++++++++++---
 scene.cpp                              | 19 ++++++--
 2 files changed, 72 insertions(+), 10 deletions(-)

diff --git a/plugins/scenes/opengl/scene_opengl.cpp b/plugins/scenes/opengl/scene_opengl.cpp
index decaaffc2..43005d75c 100644
--- a/plugins/scenes/opengl/scene_opengl.cpp
+++ b/plugins/scenes/opengl/scene_opengl.cpp
@@ -51,6 +51,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KWayland/Server/subcompositor_interface.h>
 #include <KWayland/Server/surface_interface.h>
 
+#include <algorithm>
 #include <array>
 #include <cmath>
 #include <unistd.h>
@@ -2438,6 +2439,47 @@ static QImage rotate(const QImage &srcImage, const QRect &srcRect)
     return image;
 }
 
+static inline void padScanLine(const uint *src, uint *dest, int size, int padding)
+{
+    std::fill(dest, dest + padding, *src);
+    dest += padding;
+
+    std::copy(src, src + size, dest);
+    dest += size;
+
+    std::fill(dest, dest + padding, *(src + size - 1));
+}
+
+static QImage pad(const QImage &src, int padding)
+{
+    const qreal dpr = src.devicePixelRatio();
+
+    QImage dest(src.size() + QSize(padding * 2, padding * 2), src.format());
+    dest.setDevicePixelRatio(dpr);
+
+    const uint *srcData = reinterpret_cast<const uint*>(src.scanLine(0));
+    uint *destData = reinterpret_cast<uint *>(dest.scanLine(0));
+
+    for (int i = 0; i < padding; i++) {
+        padScanLine(srcData, destData, src.width(), padding);
+        destData += dest.width();
+    }
+
+    for (int i = 0; i < src.height(); i++) {
+        padScanLine(srcData, destData, src.width(), padding);
+        srcData += src.width();
+        destData += dest.width();
+    }
+
+    srcData -= src.width();
+    for (int i = 0; i < padding; i++) {
+        padScanLine(srcData, destData, src.width(), padding);
+        destData += dest.width();
+    }
+
+    return dest;
+}
+
 void SceneOpenGLDecorationRenderer::render()
 {
     const QRegion scheduled = getScheduled();
@@ -2460,7 +2502,10 @@ void SceneOpenGLDecorationRenderer::render()
 
     const QRect geometry = dirty ? QRect(QPoint(0, 0), client()->client()->geometry().size()) : scheduled.boundingRect();
 
-    auto renderPart = [this](const QRect &geo, const QRect &partRect, const QPoint &offset, bool rotated = false) {
+    const int padding = 1;
+    const int spacing = 1;
+
+    auto renderPart = [this, padding](const QRect &geo, const QRect &partRect, const QPoint &offset, bool rotated = false) {
         if (geo.isNull()) {
             return;
         }
@@ -2469,12 +2514,14 @@ void SceneOpenGLDecorationRenderer::render()
             // TODO: get this done directly when rendering to the image
             image = rotate(image, QRect(geo.topLeft() - partRect.topLeft(), geo.size()));
         }
+        // Need to pad each part in order to avoid texture bleeding.
+        image = pad(image, padding);
         m_texture->update(image, (geo.topLeft() - partRect.topLeft() + offset) * image.devicePixelRatio());
     };
-    renderPart(left.intersected(geometry), left, QPoint(0, top.height() + bottom.height() + 2), true);
-    renderPart(top.intersected(geometry), top, QPoint(0, 0));
-    renderPart(right.intersected(geometry), right, QPoint(0, top.height() + bottom.height() + left.width() + 3), true);
-    renderPart(bottom.intersected(geometry), bottom, QPoint(0, top.height() + 1));
+    renderPart(top.intersected(geometry), top, QPoint(0, 0 * (2 * padding + spacing)));
+    renderPart(bottom.intersected(geometry), bottom, QPoint(0, top.height() + 1 * (2 * padding + spacing)));
+    renderPart(left.intersected(geometry), left, QPoint(0, top.height() + bottom.height() + 2 * (2 * padding + spacing)), true);
+    renderPart(right.intersected(geometry), right, QPoint(0, top.height() + bottom.height() + left.width() + 3 * (2 * padding + spacing)), true);
 }
 
 static int align(int value, int align)
@@ -2488,10 +2535,14 @@ void SceneOpenGLDecorationRenderer::resizeTexture()
     client()->client()->layoutDecorationRects(left, top, right, bottom);
     QSize size;
 
+    const int padding = 1;
+    const int spacing = 1;
+
     size.rwidth() = qMax(qMax(top.width(), bottom.width()),
                          qMax(left.height(), right.height()));
     size.rheight() = top.height() + bottom.height() +
-                     left.width() + right.width() + 3;
+                     left.width() + right.width() +
+                     3 * spacing + 4 * 2 * padding;
 
     size.rwidth() = align(size.width(), 128);
 
diff --git a/scene.cpp b/scene.cpp
index a12e97429..176ac8526 100644
--- a/scene.cpp
+++ b/scene.cpp
@@ -884,11 +884,22 @@ WindowQuadList Scene::Window::makeDecorationQuads(const QRect *rects, const QReg
 {
     WindowQuadList list;
 
+    const int padding = 1;
+    const int spacing = 1;
+
     const QPoint offsets[4] = {
-        QPoint(-rects[0].x() + rects[1].height() + rects[3].height() + 2, -rects[0].y()),                    // Left
-        QPoint(-rects[1].x(), -rects[1].y()),                                                                // Top
-        QPoint(-rects[2].x() + rects[1].height() + rects[3].height() + rects[0].width() + 3, -rects[2].y()), // Right
-        QPoint(-rects[3].x(), -rects[3].y() + rects[1].height() + 1)                                         // Bottom
+        // Left
+        QPoint(-rects[0].x() + rects[1].height() + rects[3].height() + 2 * (2 * padding + spacing) + padding,
+               -rects[0].y() + padding),
+        // Top
+        QPoint(-rects[1].x() + padding,
+               -rects[1].y() + 0 * (2 * padding + spacing) + padding),
+        // Right
+        QPoint(-rects[2].x() + rects[1].height() + rects[3].height() + rects[0].width() + 3 * (2 * padding + spacing) + padding,
+               -rects[2].y() + padding),
+        // Bottom
+        QPoint(-rects[3].x() + padding,
+               -rects[3].y() + rects[1].height() + 1 * (2 * padding + spacing) + padding)
     };
 
     const Qt::Orientation orientations[4] = {
-- 
2.17.1

