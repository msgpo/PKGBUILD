From 01a0a9ccfd82d384c72d469d606b23b3bcec5a6a Mon Sep 17 00:00:00 2001
From: Vlad Zagorodniy <vladzzag@gmail.com>
Date: Fri, 30 Mar 2018 18:26:53 +0300
Subject: [PATCH 4/7] [libkwineffects] Use renderbuffers as render targets

---
 libkwineffects/kwinglutils.cpp | 109 +++++++++++++++++++++++++++++++++
 libkwineffects/kwinglutils.h   |  22 +++++++
 2 files changed, 131 insertions(+)

diff --git a/libkwineffects/kwinglutils.cpp b/libkwineffects/kwinglutils.cpp
index 14db3604c..f5e0fc419 100644
--- a/libkwineffects/kwinglutils.cpp
+++ b/libkwineffects/kwinglutils.cpp
@@ -21,6 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "kwinglutils.h"
 
+#include "kwinglrenderbuffer.h"
 // need to call GLTexturePrivate::initStatic()
 #include "kwingltexture_p.h"
 
@@ -1143,6 +1144,15 @@ GLRenderTarget::GLRenderTarget(const GLTexture& texture)
     attachTexture(texture);
 }
 
+GLRenderTarget::GLRenderTarget(const GLRenderbuffer& renderbuffer)
+{
+    if (! s_supported) {
+        qCCritical(LIBKWINGLUTILS) << "Render targets aren't supported!";
+        return;
+    }
+    attachRenderbuffer(renderbuffer);
+}
+
 GLRenderTarget::~GLRenderTarget()
 {
     if (m_valid) {
@@ -1265,6 +1275,66 @@ void GLRenderTarget::attachTexture(const GLTexture& texture)
     m_valid = true;
 }
 
+void GLRenderTarget::attachRenderbuffer(const GLRenderbuffer& renderbuffer)
+{
+#if DEBUG_GLRENDERTARGET
+    GLenum err = glGetError();
+    if (err != GL_NO_ERROR)
+        qCCritical(LIBKWINGLUTILS) << "Error status when entering GLRenderTarget::initFBO: " << formatGLError(err);
+#endif
+
+    glGenFramebuffers(1, &m_framebuffer);
+
+#if DEBUG_GLRENDERTARGET
+    if ((err = glGetError()) != GL_NO_ERROR) {
+        qCCritical(LIBKWINGLUTILS) << "glGenFramebuffers failed: " << formatGLError(err);
+        return;
+    }
+#endif
+
+    glBindFramebuffer(GL_FRAMEBUFFER, m_framebuffer);
+
+#if DEBUG_GLRENDERTARGET
+    if ((err = glGetError()) != GL_NO_ERROR) {
+        qCCritical(LIBKWINGLUTILS) << "glBindFramebuffer failed: " << formatGLError(err);
+        glDeleteFramebuffers(1, &m_framebuffer);
+        return;
+    }
+#endif
+
+    glFramebufferRenderbuffer(
+        GL_FRAMEBUFFER,
+        GL_COLOR_ATTACHMENT0,
+        renderbuffer.target(),
+        renderbuffer.renderbuffer());
+
+#if DEBUG_GLRENDERTARGET
+    if ((err = glGetError()) != GL_NO_ERROR) {
+        qCCritical(LIBKWINGLUTILS) << "glFramebufferRenderbuffer failed: " << formatGLError(err);
+        glBindFramebuffer(GL_FRAMEBUFFER, 0);
+        glDeleteFramebuffers(1, &m_framebuffer);
+        return;
+    }
+#endif
+
+    const GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+    if (status != GL_FRAMEBUFFER_COMPLETE) {
+        if (status == 0) {
+            qCCritical(LIBKWINGLUTILS) << "glCheckFramebufferStatus failed: " << formatGLError(glGetError());
+        } else {
+            qCCritical(LIBKWINGLUTILS) << "Invalid framebuffer status: " << formatFramebufferStatus(status);
+        }
+        glDeleteFramebuffers(1, &m_framebuffer);
+        return;
+    }
+
+    m_viewport = QRect(0, 0, renderbuffer.width(), renderbuffer.height());
+    m_valid = true;
+}
+
 void GLRenderTarget::blitFromFramebuffer(const QRect &source, const QRect &destination, GLenum filter)
 {
     if (!GLRenderTarget::blitSupported()) {
@@ -1292,6 +1362,45 @@ void GLRenderTarget::blitFromFramebuffer(const QRect &source, const QRect &desti
     GLRenderTarget::popRenderTarget();
 }
 
+void GLRenderTarget::blitToScreen(const QRect &source, const QRect &destination, GLenum filter)
+{
+    if (! GLRenderTarget::blitSupported()) {
+        qCCritical(LIBKWINGLUTILS) << "Blit is not supported!";
+        return;
+    }
+
+    if (! m_valid) {
+        qCCritical(LIBKWINGLUTILS) << "Can't blit from invalid render target!";
+        return;
+    }
+
+    const QRect src = source.isNull() ? m_viewport : source;
+    const int srcX0 = src.x();
+    const int srcY0 = m_viewport.height() - src.y() - src.height();
+    const int srcX1 = src.x() + src.width();
+    const int srcY1 = m_viewport.height() - src.y();
+
+    const QRect dst = destination.isNull()
+        ? s_virtualScreenGeometry
+        : destination;
+    const int dstFbo = s_renderTargets.isEmpty() ? 0 : s_renderTargets.top()->m_framebuffer;
+
+    // TODO: take viewport into account.
+    const QRect screenGeo(s_virtualScreenGeometry);
+    const qreal screenScale = s_virtualScreenScale;
+    const int dstX0 = (dst.x() - screenGeo.x()) * screenScale;
+    const int dstY0 = (screenGeo.height() + screenGeo.y() - dst.y() - dst.height()) * screenScale;
+    const int dstX1 = (dst.x() - screenGeo.x() + dst.width()) * screenScale;
+    const int dstY1 = (screenGeo.height() + screenGeo.y() - dst.y()) * screenScale;
+
+    GLRenderTarget::pushRenderTarget(this);
+    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, dstFbo);
+    glBindFramebuffer(GL_READ_FRAMEBUFFER, m_framebuffer);
+    glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1,
+                      dstX0, dstY0, dstX1, dstY1,
+                      GL_COLOR_BUFFER_BIT, filter);
+    GLRenderTarget::popRenderTarget();
+}
 
 // ------------------------------------------------------------------
 
diff --git a/libkwineffects/kwinglutils.h b/libkwineffects/kwinglutils.h
index 589c1a0d8..8e5fb1b5a 100644
--- a/libkwineffects/kwinglutils.h
+++ b/libkwineffects/kwinglutils.h
@@ -45,6 +45,7 @@ template< class K, class V > class QHash;
 namespace KWin
 {
 
+class GLRenderbuffer;
 class GLVertexBuffer;
 class GLVertexBufferPrivate;
 
@@ -422,6 +423,11 @@ public:
      * @param texture texture where the scene will be rendered onto
      **/
     explicit GLRenderTarget(const GLTexture& texture);
+    /**
+     * Constructs a GLRenderTarget
+     * @param renderbuffer renderbuffer where the scene will be rendered onto
+     **/
+    explicit GLRenderTarget(const GLRenderbuffer& renderbuffer);
     ~GLRenderTarget();
 
     /**
@@ -482,9 +488,24 @@ public:
      * @param filter The filter to use if blitted content needs to be scaled.
      * @see blitSupported
      * @since 4.8
+     *
+     * TODO: blitFromScreen makes more sense.
      **/
     void blitFromFramebuffer(const QRect &source = QRect(), const QRect &destination = QRect(), GLenum filter = GL_LINEAR);
 
+    /**
+     * Blits the content of the render target into the default framebuffer.
+     *
+     * Be aware that framebuffer blitting may not be supported on all hardware. Use @link blitSupported to check whether
+     * it is supported.
+     * @param source Geometry in attached render target, if not specified complete texture is used as destination
+     * @param destination Geometry in screen coordinates which should be blitted, if not specified complete framebuffer is used
+     * @param filter The filter to use if blitted content needs to be scaled.
+     * @see blitSupported
+     * @since X.XX
+     **/
+    void blitToScreen(const QRect &source = QRect(), const QRect &destination = QRect(), GLenum filter = GL_LINEAR);
+
     /**
      * Sets the virtual screen size to @p s.
      * @since 5.2
@@ -542,6 +563,7 @@ private:
     static GLint s_virtualScreenViewport[4];
 
 private:
+    void attachRenderbuffer(const GLRenderbuffer& renderbuffer);
     void attachTexture(const GLTexture& texture);
 
 private:
-- 
2.17.0

